name: Deploy to AWS ECR and EC2

on:
  pull_request:
    types: [closed]
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'nginx/**'
      - 'docker-compose*.yml'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all images'
        required: false
        default: 'false'

# Prevent concurrent deployments - only one deployment at a time
concurrency:
  group: deploy-to-production
  cancel-in-progress: true

permissions:
  id-token: write 
  contents: read 

env:
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-north-1.amazonaws.com

jobs:
  # Detect what files changed
  detect-changes:
    runs-on: ubuntu-latest
    # Only run if PR was merged or manual trigger
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      nginx: ${{ steps.filter.outputs.nginx }}
      llm: ${{ steps.filter.outputs.llm }}
      graph: ${{ steps.filter.outputs.graph }}
      any-changes: ${{ steps.filter.outputs.changes }}
    steps:
      - uses: actions/checkout@v3
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - '!backend/app/llm_microservice/**'
              - '!backend/app/graph_microservice/**'
            frontend:
              - 'frontend/**'
            nginx:
              - 'nginx/**'
            llm:
              - 'backend/app/llm_microservice/**'
            graph:
              - 'backend/app/graph_microservice/**'

  # Setup AWS credentials once
  setup-aws:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.any-changes == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      registry: ${{ steps.login-ecr.outputs.registry }}
    steps:
      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsOIDCRole-BudgetApp
          aws-region: eu-north-1
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

  # Build only changed services in parallel
  build:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-aws]
    if: needs.detect-changes.outputs.any-changes == 'true' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        include:
          - service: backend
            context: ./backend
            dockerfile: ./backend/Dockerfile
            build-condition: ${{ needs.detect-changes.outputs.backend == 'true' || github.event.inputs.force_rebuild == 'true' }}
          - service: frontend
            context: ./frontend
            dockerfile: ./frontend/Dockerfile
            build-condition: ${{ needs.detect-changes.outputs.frontend == 'true' || github.event.inputs.force_rebuild == 'true' }}
          - service: llm
            context: ./backend/app/llm_microservice
            dockerfile: ./backend/app/llm_microservice/Dockerfile
            build-condition: ${{ needs.detect-changes.outputs.llm == 'true' || github.event.inputs.force_rebuild == 'true' }}
          - service: graph
            context: ./backend/app/graph_microservice
            dockerfile: ./backend/app/graph_microservice/Dockerfile
            build-condition: ${{ needs.detect-changes.outputs.graph == 'true' || github.event.inputs.force_rebuild == 'true' }}
    steps:
      - name: Checkout code
        if: fromJSON(matrix.build-condition)
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        if: fromJSON(matrix.build-condition)
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        if: fromJSON(matrix.build-condition)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsOIDCRole-BudgetApp
          aws-region: eu-north-1
      
      - name: Login to Amazon ECR
        if: fromJSON(matrix.build-condition)
        uses: aws-actions/amazon-ecr-login@v1

      - name: Prepare build context
        if: fromJSON(matrix.build-condition) && matrix.service == 'llm'
        run: |
          mkdir -p backend/app/llm_microservice
          echo "GEMINI_API_KEY=dummy-value-for-build" > backend/app/llm_microservice/.env

      - name: Build and push ${{ matrix.service }}
        if: fromJSON(matrix.build-condition)
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/budget-app-${{ matrix.service }}:latest
            ${{ env.ECR_REGISTRY }}/budget-app-${{ matrix.service }}:${{ github.sha }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          platforms: linux/amd64

  # Stop containers only if deployment will happen
  stop-containers:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-aws, build]
    if: needs.detect-changes.outputs.any-changes == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsOIDCRole-BudgetApp
          aws-region: eu-north-1

      - name: Stop running containers on EC2
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands":[
              "cd /home/ubuntu/budget-app-eliorabaev && docker-compose -f docker-compose.ecr.yml down || true"
            ]}' \
            --output text --query "Command.CommandId")
          
          # Wait for completion with proper timeout
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --cli-read-timeout 120

  # Deploy with optimized approach
  deploy:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-aws, build, stop-containers]
    if: needs.detect-changes.outputs.any-changes == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsOIDCRole-BudgetApp
          aws-region: eu-north-1

      - name: Deploy to EC2
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --parameters '{
              "commands":[
                "cd /home/ubuntu/budget-app-eliorabaev",
                "git pull",
                "chmod +x ./deploy-from-ecr.sh",
                "./deploy-from-ecr.sh",
                "docker ps"
              ]
            }' \
            --output text --query "Command.CommandId")
          
          # Wait for deployment completion
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --cli-read-timeout 300
          
          # Get deployment results
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query "StandardOutputContent" --output text

  # Health check after deployment
  health-check:
    runs-on: ubuntu-latest
    needs: deploy
    if: always() && needs.deploy.result == 'success'
    steps:
      - name: Wait for services to start
        run: sleep 30
      
      - name: Check application health
        run: |
          # Add your health check logic here
          # curl -f http://your-app-url/health || exit 1
          echo "Health check completed"